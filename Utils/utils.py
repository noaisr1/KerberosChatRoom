from json import load, dump
from os import path as os_path, makedirs
from typing import Optional, Union, Any
from secrets import token_bytes
from uuid import uuid4
from datetime import datetime, timedelta
from Utils.custom_exception_handler import CustomException
from Utils.validator import Validator
from Server.MsgServer.msg_server_constants import MsgConsts


DATE_TIME_FMT = "%d/%m/%y_%H:%M:%S"


def is_exists(path_to_check: str) -> bool:
    """Return True if the given path exists, False otherwise."""
    return os_path.exists(path_to_check)


def create_if_not_exists(path_to_create: str, is_file: Optional[bool] = False, is_dir: Optional[bool] = False) -> None:
    """Creates an empty file or a directory if the given path does not exist."""
    # Path exists
    if is_exists(path_to_check=path_to_create):
        return

    # Create empty file
    elif is_file:
        with open(path_to_create, 'w'):
            pass

    # Create empty directory
    elif is_dir:
        makedirs(path_to_create, exist_ok=True)

    else:
        raise ValueError(f"You must indicate if '{path_to_create}' is a directory or a file.")


def generate_uuid() -> bytes:
    """Returns a generated bytes uuid4."""
    return uuid4().bytes


def generate_nonce(size: Optional[int] = 8):
    """Returns a generated nonce token according to a given size."""
    return token_bytes(size)


def time_now() -> str:
    """Returns the time now timestamp as a string."""
    return datetime.now().strftime(DATE_TIME_FMT)


def expiration_time(days_buffer: int) -> str:
    """Returns an expiration time timestamp as a string."""
    exp_time = datetime.now() + timedelta(days=days_buffer)
    return exp_time.strftime(DATE_TIME_FMT)


def is_expired(timestamp: str) -> bool:
    """Returns True if the given timestamp as expired, False otherwise."""
    return datetime.strptime(timestamp, DATE_TIME_FMT) <= datetime.now()


def insert_data_to_template(data: dict, formatter: dict) -> dict:
    """Inserts a given data to a given dict template."""
    for key, value in formatter.items():
        if key in data:
            formatter[key] = data[key]
    return formatter


def update_template_values(template: dict, current_value: Any, new_value: Any) -> dict:
    """Updates a given dict template wit ha given value."""
    updated_template = {}
    for key, value in template.items():

        if value is not current_value:
            updated_template[key] = value
        else:
            updated_template[key] = new_value

    return updated_template


def create_info_file(file_name: str, file_data: dict) -> None:
    """Creates an info file with a given data."""
    try:
        with open(file_name, 'w') as info_file:
            for key, value in file_data.items():
                # Validate types and lengths
                Validator.validate_injection(data_type=key, value_to_validate=value)
                info_file.write(f"{value}\n")

    except Exception as e:
        raise CustomException(error_msg=f"Unable to create '{file_name}'.", exception=e)


def parse_info_file(file_path: str, target_line_number: Optional[int] = None) -> Union[dict, str, None]:
    """Returns a parsed info file data."""
    file_data = {}
    try:
        with open(file_path, 'r') as info_file:
            lines = info_file.readlines()

            for line_number, line in enumerate(lines, start=1):
                file_data[line_number] = line.strip()

                if target_line_number is not None and line_number == target_line_number:

                    return line.strip()

                if target_line_number is not None and target_line_number > len(lines):
                    return None

        return file_data

    except Exception as e:
        raise CustomException(error_msg=f"Unable to parse file {file_path}.", exception=e)


def search_value_in_txt_file(value: str, file_path: str) -> bool:
    """Returns True if the given value is in the given file, False otherwise."""
    if is_exists(file_path):
        with open(file_path, 'r') as f:
            lines = f.readlines()
        for line in lines:
            if value in line:
                return True

    return False


def fetch_dict_value(data: dict, pivot_key: str, pivot_value: Union[str, bytes, int]) -> dict:
    """Auxiliary method that returns a JSON entry from a given dict."""
    if pivot_key in data and data[pivot_key] == pivot_value:
        return data


def fetch_value_from_ram_db(data: Union[dict, list], pivot_key: str, pivot_value: Union[str, bytes, int]) -> dict:
    """Returns a JSON object from RAM memory."""
    if isinstance(data, list):
        for element in data:
            return_value = fetch_dict_value(data=element, pivot_key=pivot_key, pivot_value=pivot_value)
            if return_value is not None:
                return return_value
    elif isinstance(data, dict):
        return fetch_dict_value(data=data, pivot_key=pivot_key, pivot_value=pivot_value)
    else:
        raise ValueError(f"Data should be of type {Union[dict, list]} and not of type {type(data)}.")


def fetch_entry_from_json_db(file_path: str, pivot_key: str, pivot_value: Union[str, int]) -> dict:
    """Returns a JSON object from a given file."""
    if not is_exists(path_to_check=file_path):
        raise ValueError(f"{file_path} does not exists.")
    with open(file_path, 'r') as jf:
        data = load(jf)

        for entry in data:
            if entry.get(pivot_key) == pivot_value:
                return entry


def fetch_value_from_txt_db(file_path: str, target_value: Union[str, bytes, int]) -> Union[str, bytes, int]:
    """Returns a line from a text file."""
    if not is_exists(path_to_check=file_path):
        raise ValueError(f"{file_path} does not exists.")
    with open(file_path, 'r') as f:
        for line in f:
            if target_value in line:
                return line


def insert_value_into_info_file(value: str, target_line: int, file_path: str, max_lines: int) -> None:
    """Inserts a new value into a given file to a specific line."""
    if is_exists(file_path):
        with open(file_path, 'r') as file:
            lines = file.readlines()

        if 1 <= target_line <= len(lines) + 1:
            lines.insert(target_line - 1, f"{value}\n")

            # Truncate the lines list if max_lines is specified
            if max_lines is not None and len(lines) > max_lines:
                lines = lines[:max_lines]

            with open(file_path, 'w') as file:
                file.writelines(lines)

        else:
            print(f"Error: Line number {target_line} is out of range.")


def insert_data_to_ram_db(ram_template: dict, data: dict) -> dict:
    """Inserts a given data into a given ram dict template."""
    if not isinstance(data, dict):
        raise ValueError(
            f"Unable to insert data into RAM db, data should be of type dict and not of type {type(data)}.")
    for key, value in data.items():
        if key in ram_template and value is not None:
            ram_template[key] = value
    return ram_template


def write_line_to_info_file(file_path: str, data: dict, formatter: dict) -> None:
    """Auxiliary method to write a new line into txt file."""
    if not isinstance(data, dict):
        raise ValueError(
            f"Unable to insert data into file {file_path}, data should be of type dict and not of type {type(data)}.")
    with open(file_path, 'a') as f:
        for index, key in enumerate(formatter.keys()):
            if key in data and data[key]:
                f.write(str(data[key]))
                if index < len(formatter) - 1:
                    f.write(': ')
        f.write('\n')


def insert_data_to_txt_file_db(file_path: str, data: Union[dict, list], formatter: dict) -> None:
    """Inserts a given data to a given txt file."""
    if not is_exists(path_to_check=file_path):
        create_if_not_exists(path_to_create=file_path, is_file=True)

    if isinstance(data, list):
        for element in data:
            write_line_to_info_file(file_path=file_path, data=element, formatter=formatter)
    elif isinstance(data, dict):
        write_line_to_info_file(file_path=file_path, data=data, formatter=formatter)
    else:
        raise ValueError(f"Data should be of type {Union[dict, list]} and not of type {type(data)}.")


def create_json_file(file_path: str, data: Union[dict, list], indent_level: Optional[int] = 2) -> None:
    """Creates a JSON file."""
    with open(file_path, 'w') as jf:
        dump(data, jf, indent=indent_level)


def append_data_to_json(file_path: str, data: Union[dict, list]) -> None:
    """Adds a new JSON object to a given JSON file."""
    # Create file if not exists
    if not is_exists(path_to_check=file_path):
        create_json_file(file_path=file_path, data=data)

    else:
        # Read existing data if not empty
        if os_path.getsize(file_path) > 0:

            with open(file_path, 'r') as jf:
                existing_data = (load(jf))
        else:
            existing_data = []

        # Append the new data
        existing_data.append(data)

        # Write the updated date back to the JSON file
        create_json_file(file_path=file_path, data=existing_data)


def insert_data_to_json_db(file_path: str, data: dict, pivot_key: str, pivot_value: Any) -> None:
    """Inserts a given data into JSON file."""
    if not isinstance(data, dict):
        raise ValueError(
            f"Unable to insert data into file {file_path}, data should be of type dict and not of type {type(data)}.")
    if not is_exists(path_to_check=file_path):
        raise FileNotFoundError(f"Unable to find file '{file_path}'.")

    with open(file_path, 'r') as input_file:
        file_data = load(input_file)

    for item in file_data:
        if item[pivot_key] == pivot_value:
            for key, value in data.items():
                if key in item and value is not None:
                    item[key] = value

    with open(file_path, 'w') as output_file:
        dump(file_data, output_file, indent=2)


def parse_msg_info_file() -> tuple:
    """Parses the default service data from msg.info file."""
    try:
        # Parse default service data
        ip_and_port = parse_info_file(file_path=MsgConsts.MSG_FILE_NAME,
                                      target_line_number=MsgConsts.LINE_IP_PORT)
        server_id = parse_info_file(file_path=MsgConsts.MSG_FILE_NAME, target_line_number=MsgConsts.LINE_ID)
        server_name = parse_info_file(file_path=MsgConsts.MSG_FILE_NAME, target_line_number=MsgConsts.LINE_NAME)
        server_aes_key = parse_info_file(file_path=MsgConsts.MSG_FILE_NAME, target_line_number=MsgConsts.LINE_AES_KEY)

        # Return as a Tuple
        return ip_and_port, server_name, server_id, server_aes_key

    except Exception as e:
        raise CustomException(error_msg=f"Unable to parse {MsgConsts.MSG_FILE_NAME}.", exception=e)